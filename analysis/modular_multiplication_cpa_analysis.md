# 模乘模块CPA攻击分析

## 1. 功耗曲线数据格式

### 1.1 数据文件结构
- **主要数据文件**: `data/ntt_pipeline_traces_x10k-3rd.txt`
- **数据格式**: 每行包含一个明文和对应的功耗迹线
- **分隔符**: 冒号(`:`)分隔明文和功耗迹线
- **明文格式**: 十进制数值
- **功耗迹线格式**: 空格分隔的浮点数序列

### 1.2 数据示例格式
```
1000: 0.123 0.456 0.789 ... (5000个功耗采样点)
1001: 0.234 0.567 0.890 ...
...
```

### 1.3 硬件采集参数
根据 `mainwindow_MD04034C.cpp` 中的配置:
- **时间刻度**: 400μs (PWM_Pipeline_Time)
- **触发方式**: 下降沿触发 (fAll)
- **数据范围**: 1M-9M 采样点
- **采集模式**: 高精度模式 (HIRes)
- **每个运算**: 2500个采样点，取790-840区间

## 2. 功耗曲线与硬件模块输入的对应关系

### 2.1 NTT流水线结构
- **1500段运算**: 每段包含3个峰值
  - 第一个峰: 8200 + j + 5000*k
  - 第二个峰: 9050 + j + 5000*k  
  - 第三个峰: 9900 + j + 5000*k
- **每段长度**: PWM_Pipeline_onetrace 个采样点

### 2.2 模乘运算对应
- **输入数据**: 明文通过NTT变换后的系数
- **密钥**: 1000 (二进制: 1111101000)
- **运算类型**: 模乘运算 (mod 8380417)
- **功耗特征**: 位翻转、进位传播、NTT特定运算

### 2.3 硬件触发机制
- **GPIO信号**:
  - `gpio_startn`: 运算开始信号
  - `gpio_endn`: 运算结束信号
  - `gpio_exec`: 执行信号
- **触发同步**: 确保功耗采集与运算同步

## 3. CPA攻击方法

### 3.1 基础CPA攻击流程

#### 步骤1: 数据预处理
```python
# 读取功耗迹线
plaintext_str, power_trace_str = line.split(':', 1)
plaintext = int(plaintext_str, 10)  # 十进制明文
power_trace = np.array(power_trace_str.strip().split()).astype(np.float64)
```

#### 步骤2: 功耗模型构建
- **汉明重量模型**: `bin(plaintext ^ key_guess).count('1')`
- **位翻转模型**: 捕获位变化的功耗特征
- **NTT特定模型**: 针对NTT运算的功耗特征

#### 步骤3: 相关性分析
```python
# 计算皮尔逊相关系数
correlation = np.corrcoef(theoretical_power, actual_power)[0,1]
```

### 3.2 改进的CPA攻击

#### 多模型集成
- **位转换模型**: 专门针对位翻转模式
- **进位传播模型**: 捕获进位操作的功耗
- **条件约简模型**: 针对模约简运算

#### 攻击目标分解
- **低3位攻击**: 密钥的0-2位
- **4-6位攻击**: 密钥的3-5位
- **多位联合攻击**: 同时攻击多个位

### 3.3 模板攻击方法 (analysis/find_max.py)

#### 数据处理流程
1. **读取PWM_Pipeline_Data目录**: 包含3327个txt文件
2. **数据分组**: 每600行为一组，提取最大值
3. **相关性计算**: 使用自定义的相关系数函数
4. **结果输出**: 保存到Excel文件进行分析

#### 关键算法
```python
def calculate_r(H, T):
    h_bar = sum(H) / len(H)
    t_bar = sum(T) / len(T)
    h_sigma = sum([(h - h_bar) ** 2 for h in H])
    t_sigma = sum([(t - t_bar) ** 2 for t in T])
    ht_sum = sum([(H[i] - h_bar) * (T[i] - t_bar) for i in range(len(H))])
    r = ht_sum / (h_sigma * t_sigma) ** 0.5
    return r
```

## 4. 攻击结果分析

### 4.1 成功案例
- **低3位攻击**: 位转换模型成功识别密钥0，相关系数0.665932
- **模型对比**: 位转换模型 > NTT特定模型 > 条件约简模型

### 4.2 挑战与限制
- **4-6位攻击**: 相关系数差距小，需要更多样本
- **噪声影响**: 功耗测量中的噪声干扰
- **模型精度**: 功耗模型与实际硬件行为的匹配度

### 4.3 改进建议
1. **增加样本数量**: 提高统计显著性
2. **优化功耗模型**: 更精确地建模硬件行为
3. **多位联合攻击**: 利用位间相关性
4. **高级统计方法**: 使用更复杂的统计分析
5. **硬件特性建模**: 考虑具体FPGA的功耗特性

## 5. 实际应用

### 5.1 攻击环境
- **目标设备**: SAKURA-X FPGA开发板
- **测量设备**: 示波器 (MDO配置)
- **攻击软件**: Python CPA分析工具

### 5.2 防护建议
- **随机化**: 添加随机延迟和虚拟操作
- **掩码**: 使用布尔掩码或算术掩码
- **功耗均衡**: 实现功耗无关的电路设计
- **噪声注入**: 主动添加功耗噪声

## 6. 总结

模乘模块的CPA攻击通过分析功耗迹线与密钥相关的统计特征来恢复密钥信息。成功的攻击需要:
1. 精确的功耗测量和同步
2. 合适的功耗模型
3. 足够的统计样本
4. 有效的相关性分析方法

通过位转换模型等改进方法，可以显著提高攻击成功率，但对于高位攻击仍需要进一步的技术改进。